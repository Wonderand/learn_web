<!DOCTYPE html>
<html>

<head>
    <script src="../utils/konva.js"></script>
    <meta charset="utf-8" />
    <title>Konva Rect Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <div>
        <button id="button">点我开始绘制</button>
    </div>
    <div id="container">
    </div>

    <script>
        let btn = document.getElementById("button");
        let canvasWrapper = document.getElementById("container");
        let width = window.innerWidth;
        let height = window.innerHeight;
        let isDraw;
        let onDraw = false;
        let isMouseDown = false;
        let isTransform = false;
        // 创建一个数组来存储所有的 Transformer
        let transformers = [];
        // 创建一个数组来存储所有的矩形
        let rects = [];
        // 创建一个 Konva.Stage 实例
        let stage = new Konva.Stage({
            container: 'container',
            width: width,
            height: height,
        });
        let rect;
        btn.addEventListener("click", function () {
            if (isDraw) {
                isDraw = false;
            } else {
                isTransform = false;
                isDraw = true;
            }
            console.log("1", isDraw, isTransform);
        })
        let layer = new Konva.Layer();

        canvasWrapper.addEventListener("mousedown", function (ev) {
            if (!isDraw) {
                return;
            }
            if (onDraw) {
                return;
            }
            console.log("isTransform", isTransform);
            if (isTransform) {
                return;
            }
            isMouseDown = true;
            let pos = stage.getPointerPosition();
            rect = new Konva.Rect({
                x: pos.x,
                y: pos.y,
                width: 0,
                height: 0,
                stroke: 'red',
                draggable: true,
                strokeWidth: 2,
            });
            rects.push(rect);
            layer.add(rect);
        });

        canvasWrapper.addEventListener("mousemove", function (ev) {
            if (isMouseDown) {
                if (!isDraw) {
                    return;
                }
                if (onDraw) {
                    return;
                }
                if (isTransform) {
                    return;
                }
                let pos = stage.getPointerPosition();
                rect.width(pos.x - rect.x());
                rect.height(pos.y - rect.y());
                layer.draw();
                stage.add(layer);
            }
        });

        canvasWrapper.addEventListener("mouseup", function (ev) {
            console.log("mouseup");
            if (!isDraw) {
                return;
            }
            if (onDraw) {
                return;
            }
            onDraw = true;
            isMouseDown = false;
            console.log("mouseup", isDraw);
            let transformer = new Konva.Transformer({
                borderStrokeWidth: 2,
            });
            layer.add(transformer);
            rects.forEach(function (rect) {
                let transformer = new Konva.Transformer();
                transformers.push(transformer);
                layer.add(transformer);
                // transformer.attachTo(rect);
            });
            stage.on('click', function (e) {
                isTransform = true;
                // 获取点击的目标
                let target = e.target;
                // 检查目标是否在 rects 数组中
                let index = rects.indexOf(target);

                // 如果目标在 rects 数组中，显示对应的 Transformer
                if (index !== -1) {
                    isTransform = true;
                    transformers.forEach(function (transformer, i) {
                        if (i === index) {
                            transformer.nodes([rects[i]]);
                        } else {
                            transformer.nodes([]);
                        }
                    });
                    layer.draw();
                }
                // 如果目标不在 rects 数组中，隐藏所有的 Transformer
                else {
                    transformers.forEach(function (transformer) {
                        transformer.nodes([]);
                    });
                    layer.draw();
                }
            });
            rect.on('transformend', function () {
                console.log("transformend");
                // 获取矩形的缩放因子
                let scaleX = rect.scaleX();
                let scaleY = rect.scaleY();

                // 重新设置边框宽度
                rect.strokeWidth(2 / scaleX);

                // 调整矩形的宽度和高度为缩放后的值
                rect.width(rect.width() * scaleX);
                rect.height(rect.height() * scaleY);

                // 重置形状的缩放因子
                rect.scaleX(1);
                rect.scaleY(1);

                layer.draw();
            });
            // 移动矩形
            rect.on('mouseover', function () {
                console.log("mouseover");
                onDraw = true;
                document.body.style.cursor = 'pointer';
            });
            rect.on('mouseout', function () {
                console.log("mouseout");
                onDraw = false;
                isDraw = isDraw ? true : false;
                document.body.style.cursor = 'default';
            });
        })
    </script>
</body>

</html>